;CPM-65 BIOS for JC II

;D. LAUSBERG	(C) 1987

;V0.1	06.07.23	JC II version, erster Anlauf
;V0.2	25.07.23	error corrections & mount function
;V0.3	29.07.23	error correction in SETLBA
;V0.4	02.08.23	error correction MODE adr

VERSION	= $04		;VERSION NUMBER

;FORMAT	SD	1024 KBYTES/DISK

;=====================================

;PAGE 00 CELLS

DMAV	= $FE		;DMA-VECTOR
DIRBFV	= $FC		;DIRBF-VECTOR
BLKB	= $FA		;BIOS Block Pointer
DPHV	= $F8		;DPH-VECTOR
JPBDOS	= $F0
MODE	= $1A		;SD Mode byte 0 byte mode; <>0 block mode

;SYSTEM CONSTANTS

BLKBUF	=  $600		;default buffer

CCP	= $CC00
BEGIN	= $D800

CGET = $E04D		;CGET
ROM_CONIN = $E047	;CIN
ROM_CONOUT = $E044	;BOUT
SD_INIT	= $F38F		;SD card initialization
SD_RD_LBLK_BUF = $F45F	;load sector in LBA to BLKBUF
SD_WR_LBLK_BUF = $F492	;save sector in BLKBUF to LBA

ROM_MONITOR = $E000	;Monitor cold start

;CONTROL CODES

BREAKC	= $03		;BREAK CODE
CLS	= $0C		;CLEAR SCREEN

;ERROR CODES

INVDRV	= $F9		;invalid drive

;CONSTANTS

MAXTRK	= 128

SPT	= 32		;SECTORS PER TRACK
SPTDIV	= 5		;log(2) SPT
SPB	= 8		;SECTORS PER BLOCK
SPBDIV	= 3		;LOG(2) SPB
SYS	= 32		;SYSTEM sectors
BPD	= MAXTRK*SPT-SYS/SPB-1	;BLOCKS PER DISK
DIRSCS	= 32		;DIRECTORY SECTORS
DIRMSK	= %11110000	;DIR MASK FOR BAT
RPEXT	= 8*SPB*2 	;RECORD PER EXTENT
BATSIZ	= BPD/8		;SIZE OF BAT (64 bytes)

;==========================================

	ORG BEGIN

FBIOS	JMP BOOT		; 00
	JMP WBOOT		; 01
	JMP CONST		; 02
	JMP ROM_CONIN		; 03
	JMP ROM_CONOUT		; 04
	JMP LIST		; 05
	JMP AUXOUT		; 06
	JMP AUXIN		; 07
	JMP HOME		; 08
	JMP SELDSK		; 09
	JMP SETTRK		; 0A
	JMP SETSEC		; 0B
	JMP READ		; 0C
	JMP WRITE		; 0D
	JMP LISTST		; 0E
	JMP GET_VERSION		; 0F
	JMP ROM_MONITOR		; 10
	JMP MOUNT		; 11

;========== DATA AREA =============
;--- Disk Image TABLE ---

IMGTAB	DS 4*4,0	;Base Sector address of disk images mounted
IMGSTAT	DS 4,0		;Flag $FF valid image, $00 no image

;Disk parameter block

DPHA	DW DIRBF	;DISK PARAMETER HEADER
	DW DMA		;FOR DRIVE A to D
	DW BAT

	DB SPB-1	;DISK PARAMETER BLOCK FOR DISK A-D
	DB SPBDIV
	DW BPD
	DB DIRSCS
	DB DIRMSK
	DB RPEXT
	DB SYS,0,0
	DB BATSIZ
SD_TYPE	DB 0		;SD card type

BAT	DB %11110000	;Block Allocation Table Drive A-D
	DS BATSIZ	;max. 1 page

DRIVE	DB 0		;active drive

SECS	DS 4,0		;CPM-65 sector #, Byte 4 is not used

;--- buffer for SD CARD

LBA	DS 4,0		;LSB ... MSB
LBA_B	DS 4,$FF
LBA_F	DB 0		;LBA FLAG BIT7 = dirty

;==================================

BOOT	LDA #$4C		;SET JMP BDOS
	STA JPBDOS
	LDA #CCP
	STA JPBDOS+1
	LDA #CCP/256
	STA JPBDOS+2
	LDA #0			;A: only
	STA DRIVE		;SELECT BOOT DRIVE
	LDX #$0E		;VIA BDOS
	JSR JPBDOS
	LDX #0 			;WARM BOOT
	JMP JPBDOS


WBOOT	LDA DRIVE		;SELECT DEFAULT DRIVE
	JSR SELDSK
	RTS


CONST	JSR CGET
	LDA #BREAKC
	BCS CONST1
	LDA #0
CONST1	CLC
	RTS


;---	CONIN	JMP ROM_CONIN


;---	CONOUT	JMP ROM_CONOUT


LIST	RTS


AUXOUT	RTS

AUXIN	RTS


HOME	RTS


SELDSK	CMP #4			;TEST FOR DRIVE A to D
	BCS SELDS2		;Invalid drive
	STA DRIVE		;SELECT DISK LOGICAL
	LDA #DPHA		;SET DPHVEC
	STA DPHV
	LDA #DPHA/256
	STA DPHV+1
	CLC
	RTS

SELDS2	LDA #INVDRV
	RTS


SETSEC	TAX			;sector pointer for p.00 in Accu
	LDA 0,X
	STA SECS
	LDA 1,X
	STA SECS+1
	LDA 2,X
	STA SECS+2
	RTS


SETTRK	LDA #$FB		;Sector not found
	SEC
	RTS


READ	JSR SETLBA		;SET LBA = IMGTAB + SECS/2
	BCS SD_RDX
	JSR CHKBLK		;CHECK IF BLOCK VALID
	BCC SD_RD1
	JSR S_READ
	BCS SD_RD4
SD_RD1	LDA SECS
	LSR A
	LDY #0
	BCS SD_RD3
SD_RD2	LDA BLKBUF,Y
	STA (DMAV),Y
	INY
	BNE SD_RD2
	CLC
	RTS

SD_RD3	LDA BLKBUF+256,Y
	STA (DMAV),Y
	INY
	BNE SD_RD3
	CLC
	RTS

SD_RD4	JSR SD_INIT		;on error retry
	BCS READ
	SEC
SD_RDX	RTS


WRITE	JSR SETLBA		;WRITE SD card
	BCS SD_RDX
	JSR CHKBLK
	BCC SD_WR1
	JSR S_READ		;write implicitely
	BCS SD_WRE		;when SD buffer dirty
SD_WR1	LDA SECS
	LSR A
	LDY #0
	BCS SD_WR2
SD_WR3	LDA (DMAV),Y
	STA BLKBUF,Y
	INY
	BNE SD_WR3
	BEQ SD_WR4

SD_WR2	LDA (DMAV),Y
	STA BLKBUF+256,Y
	INY
	BNE SD_WR2	
SD_WR4	LDA #$80
	STA LBA_F		;BLKBUF dirty
	LDA SECS+2		;is it a dir sector?
	BNE SD_WR5
	LDA SECS+1
	BNE SD_WR5
	LDA SECS
	CMP #SYS+DIRSCS		
	BCS SD_WR5
	JSR SD_WB		;then write SD block immediate
	RTS

SD_WR5	CLC
	RTS

SD_WRE	JSR SD_INIT		;on error 1 retry
	BCS WRITE
	SEC
	RTS


LISTST	RTS



GET_VERSION			;GET VERSION NUMBER

	LDA #VERSION
	RTS


MOUNT	TAX			;mount disk image on SD
	LDA 0,X			;load drive to be mounted
	CMP #4			;max A: - D:
	BCS MOU_ERR
	TAY
	LDA #$FF		;set drive byte as valid
	STA IMGSTAT,Y
	TYA
	ASL A			;*4
	ASL A
	TAY
MOUNT1	INX
	LDA 0,X
	STA IMGTAB,Y		;copy LBA block 0
	INY
	CPX #4			;4 bytes LBA
	BCC MOUNT1
	CLC
	RTS

MOU_ERR	LDA #INVDRV		;invalid drive #
	SEC
	RTS

;====== SUBROUTINES =======

SETLBA	LDX DRIVE
	LDA IMGSTAT,X	;Check for valid image base adr
	BEQ SETLBX
	TXA		;Drive*4 = pnt for base LBA
	ASL A
	ASL A
	TAX
	LDY #2
	CLC
SETLBA0	LDA SECS,Y	;SECS/2
	ROR A
	STA LBA,Y
	DEY
	BPL SETLBA0
	INY		;Y=0
	LDA #4
	STA MODE	;counter for addition
	CLC
SETLBA1	LDA LBA,Y	;LBA = IMGTAB + SECS/2
	ADC IMGTAB,X
	STA LBA,Y
	INX
	INY
	DEC MODE
	BNE SETLBA1
	LDA SD_TYPE	;set mode byte
	STA MODE
	CLC
	RTS

SETLBX	LDA #INVDRV
	SEC
	RTS


CHKBLK	LDY #3		;CHECK IF BLK IN BUFFER VALID
CHKBLK2	LDA LBA,Y	;C=1 invalid
	CMP LBA_B,Y
	BNE CHKBL1
	DEY
	BPL CHKBLK2
	LDA LBA_F
	ASL A
	RTS

CHKBL1	SEC
	RTS


S_READ	BIT LBA_F		;SD_READ
	BPL S_READ1		;if buffer dirty
	JSR S_SAVE		;SAVE SD_BUFFER
	BCS S_READX
S_READ1	JSR PUSH_E0
	LDX #LBA		;load LBA to BLKBUF
	LDY #LBA/256
	JSR SD_RD_LBLK_BUF
	JSR PULL_E0
	BCS S_READX
	SEC
	RTS

S_READX	JSR SD_UPD		;UPDATE BLK/FLAG INFO
	CLC
	RTS


S_SAVE	JSR PUSH_E0
	LDX #LBA_B		;save old buffer to SD
	LDY #LBA_B/256
	JSR SD_WR_LBLK_BUF
	JSR PULL_E0
	BCC S_SAVEX
	CLC
	RTS

S_SAVEX	SEC
	RTS


SD_WB	JSR PUSH_E0
	LDX #LBA		;Write SD_ block pysically
	LDY #LBA/256
	JSR SD_WR_LBLK_BUF
	BCS S_READX
	JSR PULL_E0
	SEC
	RTS


SD_UPD	LDA LBA+3		;save LBA AND update LBA_FLAG
	STA LBA_B+3
	LDA LBA+2
	STA LBA_B+2
	LDA LBA+1
	STA LBA_B+1
	LDA LBA
	STA LBA_B
	LDA #0
	STA LBA_F
	RTS


PUSH_E0	LDX #$E3		;Save $E3..E0
	LDY #4			;4 bytes to be saved
PUSH_E1	LDA 0,X
	STA E0BUF,X
	DEX
	DEY
	BNE PUSH_E1
	RTS


PULL_E0	LDX #$E3		;Save $E3..E0
	LDY #4			;4 bytes to be saved
	PHA			;save A
PULL_E1	LDA E0BUF,X
	STA 0,X
	DEX
	DEY
	BNE PULL_E1
	PLA			;A & C unchanged
	RTS

E0BUF	DS 4,0
	
DMA	

DIRBF	=  DMA+256


	END
