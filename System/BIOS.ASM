;CPM-65 BIOS for JC II

;D. LAUSBERG	(C) 1987

;V0.1	06.07.23	JC II version, erster Anlauf

VERSION	= $01		;VERSION NUMBER

;FORMAT	SD	1024 KBYTES/DISK

;=====================================

;PAGE 00 CELLS

DMAV	= $FE		;DMA-VECTOR
DIRBFV	= $FC		;DIRBF-VECTOR
BIOSP	= $FA		;BIOS-POINTER
DPHV	= $F8		;DPH-VECTOR
JPBDOS	= $F0

;SYSTEM CONSTANTS

BLKBUF	=  $600		;default buffer

CCP	= $AC00
BEGIN	= $B800

CGET = $E04D			;CGET
ROM_CONIN = $E047		;CIN
ROM_CONOUT = $E044		;BOUT
SD_RD_LBLK_BUF = $F458		;load sector in LBA to BLKBUF
SD_WR_LBLK_BUF = $f48B		;save sector in BLKBUF to LBA

ROM_MONITOR = $E000		;Monitor cold start

;CONTROL CODES

BREAKC	= $03		;BREAK CODE
CLS	= $0C		;CLEAR SCREEN

;ERROR CODES

INVDRV	= $F9		;invalid drive
SD_ERROR = $F6
I2CError = $F5
NO_DEV	= $F4
ID_NFND	= $F3

;CONSTANTS

MAXTRK	= 128

SPT	= 32		;SECTORS PER TRACK
SPTDIV	= 5		;log(2) SPT
SPB	= 8		;SECTORS PER BLOCK
SPBDIV	= 3		;LOG(2) SPB
SYS	= 32		;SYSTEM sectors
BPD	= MAXTRK*SPT-SYS/SPB-1	;BLOCKS PER DISK
DIRSCS	= 32		;DIRECTORY SECTORS
DIRMSK	= %11000000	;DIR MASK FOR BAT
RPEXT	= 8*SPB*2 	;RECORD PER EXTENT
BATSIZ	= BPD/8		;SIZE OF BAT

;==========================================

	ORG BEGIN

FBIOS	JMP BOOT		; 00
	JMP WBOOT		; 01
	JMP CONST		; 02
	JMP ROM_CONIN		; 03
	JMP ROM_CONOUT		; 04
	JMP LIST		; 05
	JMP AUXOUT		; 06
	JMP AUXIN		; 07
	JMP HOME		; 08
	JMP SELDSK		; 09
	JMP SETTRK		; 0A
	JMP SETSEC		; 0B
	JMP READ		; 0C
	JMP WRITE		; 0D
	JMP LISTST		; 0E
	JMP GET_VERSION		; 0F
	JMP ROM_MONITOR		; 10

;========== DATA AREA =============
;--- Disk Image TABLE ---

IMGTAB	DS 4*4		;Base Sector address of disk images mounted
IMGSTAT	DS 4,0		;Flag $FF valid image, $00 no image

;Disk parameter block

DPHA	DW DIRBF	;DISK PARAMETER HEADER
	DW DMA		;FOR DRIVE A to D
	DW BAT

	DB SPB-1	;DISK PARAMETER BLOCK FOR DISK A-D
	DB SPBDIV
	DW BPD
	DB DIRSCS
	DB DIRMSK
	DB RPEXT
	DB SYS,0,0
	DB BATSIZ


BAT	DB %10000000	;Block Allocation Table Drive A-D
	DS BATSIZ	;max. 1 page

DRIVE	DB 0		;active drive

SECS	DS 4,0		;CPM-65 sector #, Byte 4 is not used

;--- buffer for SD CARD

LBA	DS 4
LBA_B	DS 4
LBA_F	DB 0		;LBA FLAG BIT7 = dirty

;==================================

BOOT	LDA #$4C		;SET JMP BDOS
	STA JPBDOS
	LDA #CCP
	STA JPBDOS+1
	LDA #CCP/256
	STA JPBDOS+2
	JSR HOME		;HOME BOOT DISK
	LDA DRIVE		;SELECT BOOT DRIVE
	LDX #$0E		;VIA BDOS
	JSR JPBDOS
	LDX #0 			;WARM BOOT
	JMP JPBDOS


WBOOT	LDA DRIVE		;SELECT DEFAULT DRIVE
	JSR SELDSK
	RTS


CONST	JSR CGET
	LDA #BREAKC
	BCS CONST1
	LDA #0
CONST1	CLC
	RTS


;---	CONIN	JMP ROM_CONIN


;---	CONOUT	JMP ROM_CONOUT


LIST	RTS


AUXOUT	RTS

AUXIN	RTS


HOME	RTS


SELDSK	CMP #4			;TEST FOR DRIVE A to D
	BCS SELDS2		;Invalid drive
	STA DRIVE		;SELECT DISK LOGICAL
	LDA #DPHA		;SET DPHVEC
	STA DPHV
	LDA #DPHA/256
	STA DPHV+1
	CLC
	RTS

SELDS2	LDA #INVDRV
	RTS


SETSEC	TAX			;sector pointer for p.00 in Accu
	LDA 0,X
	STA SECS
	LDA 1,X
	STA SECS+1
	LDA 2,X
	STA SECS+2
	RTS


SETTRK	LDA #$FB		;Sector not found
	SEC
	RTS


READ	JSR SETLBA		;SET LBA = IMGTAB + SECS
	JSR CHKBLK		;CHECK IF BLOCK VALID
	BCC SD_RD1
	JSR S_READ
	BCS SD_RDX
SD_RD1	LDA SECS
	LSR A
	LDY #0
	BCS SD_RD3
SD_RD2	LDA BLKBUF,Y
	STA (DMAV),Y
	INY
	BNE SD_RD2
	CLC
	RTS

SD_RD3	LDA BLKBUF+256,Y
	STA (DMAV),Y
	INY
	BNE SD_RD3
	CLC
SD_RDX	RTS


WRITE	JSR SETLBA		;WRITE SD card
	JSR CHKBLK
	BCC SD_WR1
	JSR S_READ		;write implicitely
	BCS SD_WRX		;when SD buffer dirty
SD_WR1	LDA SECS
	LSR A
	LDY #0
	BCS SD_WR2
SD_WR3	LDA (DMAV),Y
	STA BLKBUF,Y
	INY
	BNE SD_WR3
	BEQ SD_WR4

SD_WR2	LDA (DMAV),Y
	STA BLKBUF+256,Y
	INY
	BNE SD_WR2	
SD_WR4	LDA #$80
	STA LBA_F		;BLKBUF dirty
	LDA SECS+2		;is it a dir sector?
	BNE SD_WR5
	LDA SECS+1
	BNE SD_WR5
	LDA SECS
	CMP #SYS+DIRSCS		
	BCS SD_WR5
	JSR SD_WB		;then write SD block immediate
SD_WRX	RTS

SD_WR5	CLC
	RTS


LISTST	RTS



GET_VERSION			;GET VERSION NUMBER

	LDA #VERSION
	RTS


;====== SUBROUTINES =======

SETLBA	LDX DRIVE
	LDA IMGSTAT,X	;Check for valid image base adr
	BEQ SETLBX
	TXA		;Drive*4 = pnt for base LBA
	LSR A
	LSR A
	TAX
	LDY #2
	CLC
SETLBA0	LDA SECS,Y	;SECS/2
	ROR A
	STA LBA,Y
	DEY
	BPL SETLBA0
	INY
	TYA
SETLBA1	ROR A		;set C from A Bit0
	LDA LBA,Y	;LBA = IMGTAB + SECS/2
	ADC IMGTAB,X
	STA LBA,Y
	INX
	INY
	ROL A		;save C in A Bit0
	CPY #4
	BCC SETLBA1
	CLC
	RTS

SETLBX	LDA #INVDRV
	CLC
	RTS


CHKBLK	LDY #3		;CHECK IF BLK IN BUFFER VALID
CHKBLK2	LDA LBA,Y	;C=1 invalid
	CMP LBA_B,Y
	BNE CHKBL1
	DEY
	BPL CHKBLK2
	LDA LBA_F
	LSR A
	RTS

CHKBL1	SEC
	RTS



S_READ	BIT LBA_F		;SD_ READ
	BPL S_READ1		;if buffer dirty
	JSR S_SAVE		;SAVE SD_ BUFFER
	BCS S_READX
S_READ1	LDX #LBA		;load LBA to BLKBUF
	LDY #LBA/256
	JSR SD_RD_LBLK_BUF
	BCS S_READX
	SEC
	RTS

S_READX	JSR SD_UPD		;UPDATE BLK/FLAG INFO
	CLC
	RTS


S_SAVE	LDX #LBA_B		;save old buffer to SD
	LDY #LBA_B/256
	JSR SD_WR_LBLK_BUF
	BCC S_SAVEX
	CLC
	RTS

S_SAVEX	SEC
	RTS


SD_WB	LDX #LBA		;Write SD_ block pysically
	LDY #LBA/256
	JSR SD_WR_LBLK_BUF
	BCS S_READX
	SEC
	RTS


SD_UPD	LDA LBA+3		;save LBA AND update SD_ FLAG
	STA LBA_B+3
	LDA LBA+2
	STA LBA_B+2
	LDA LBA+1
	STA LBA_B+1
	LDA LBA
	STA LBA_B
	LDA #0
	STA LBA_F
	RTS

	
DMA	

DIRBF	=  DMA+256


	END
