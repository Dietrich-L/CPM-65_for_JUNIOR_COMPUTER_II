;BASIC.COM  Microsoft compatible 6502 BASIC
;JC II version adapted to VDU ROM Software

;D. Lausberg	(c) 1995
;V1.0	08.04.95
;V1.1	02.09.95	EDIT COMMAND and LINE EDITOR
;V1.2	13.01.96	G_FIX Error corrected
;V1.3	17.01.96	upper case conversion, PI
;V1.4	06.03.96	printer,disk support
;V1.5	12.06.22	BASIC filename implemented
;V1.6	25.04.24	JC-II adaption (EDIT, CHRIN, RND, BS)
Version = $16

;Parameters
ZERO	= $00		;ZERO PAGE
SRC_CHR	= $03		;SEARCH CHR
HK_F	= $04		;FLAG FOR HOCHKOMMA MODE
INBUFP	= $05		;INPUT BUFFER POINTER
DIMBUF	= $06		;1. CHR OF DIM VARIABLE
VAR_F	= $07		;VARIABLE TYPE FLAG
INT_F	= $08		;INTEGER FLAG
DATA_F	= $09		;DATA FLAG
DIM_F	= $0A		;DIM FLAG
INP_F	= $0B		;INPUT FLAG
SGN_F	= $0C		;SIGN FLAG
OUT_F	= $0D		;OUTPUT FLAG
IO_CHAN	= $0E		;NR OF I/O CHANNEL 0=KEYB 3=SCREEN
BASADR	= $11		;BASIC ADDRESS
DES_PNT	= $13		;POINTER TO NEXT DESCRIPTOR
L_STRP	= $14		;POINTER ON LAST RECENTLY USED STRING
STRTAB	= $16		;STRING DESCRIPTOR TABLE
T_PNT	= $1F		;TRANSFER POINTER
PNT	= $21		;GENERAL PURPOSE POINTER
REG	= $23		;REGISTER FOR FUNCTION ARGUMENTS
BASBEG	= $28		;BEGIN OF BASIC STATEMENTS
VTBEG	= $2A		;POINTER TO BEGIN OF VARIABLES TABLE
ATBEG	= $2C		;POINTER TO BEGIN OF ARRAY TABLE
VTEND	= $2E		;POINTER TO END OF VARIABLES TABLE
STREND	= $30		;POINTER TO END OF STRING AREA
STRBEG	= $32		;POINTER TO BEGIN OF LAST STRING
NXTAD	= $34		;POINTER TO NEXT ADDRESS IN RAM
ALINNR	= $36		;NR OF ACTUAL BASIC LINE
DIRECT_F = $37		;FLAG FOR DIRECT MODE
CONTLN	= $38		;LINE NR FOR CONT COMMAND
NXTBEF	= $3A		;POINTER ON NEXT BASIC COMMAND
ADATA	= $3C		;LINE NR OF ACTUAL DATA
NXTDATA	= $3E		;POINTER ON NEXT DATA
INPPNT	= $40		;INPUT SOURCE POINTER
VNAME	= $42		;NAME OF CURRENT VARABLE
VPNT	= $44		;POINTER ON CURRENT VARABLE
P_FORL	= $46		;POINTER ON FOR/NEXT VARIABLE
AOPER	= $48		;POINTER ON ACTUAL OPERATOR

OPMSK	= $4A		;OPERATOR MASK
DEFPNT	= $4B		;DEF FN POINTER
GCMEM	= $4D		;GARBAGE COLLECTION MEMORY

J_FN	= $51		;JUMP TO BASIC FUNCTION
BUF1	= $54		;BUFFER FOR ARGUMENTS 1
TARGAD	= $55		;LAST TARGET ADDRESS OF MOVE
ENDAD	= $57		;END ADDRESS OF BLOCK TO BE MOVED
BUF2	= $59		;BUFFER FOR ARGUMENTS 2
BEGAD	= $5C		;START ADDRESS OF BLOCK TO BE MOVED
F_ACCU1	= $5E		;FLOATING POINT ARITH ACCU 1

F_ACCU2	= $66		;FLOATING POINT ARITH ACCU 2

ACOMP	= $6C		;ACCU COMPARISON BYTE
ARND	= $6D		;ACCU ROUND BYTE
P_FUNC	= $6E		;POINTER FOR FUNCTION PROCESSING
CHRGTP	= $71		;CHR GET POINTER

RNDNR	= $76		;RANDOM NR
CLOCK	= $7B		;24H CLOCK
STATUS	= $7E		;STATUS VARABLE
CUR_COL	= $7F		;CURSOR COLOUMN

;SYSTEM ADDRESSES

TEMPX	= $80
TEMPY	= $81
BUFPNT	= $82		;Pointer for disk buffer (=DMA)
FLAG_8	= $83		;Channel #8 Flag
IN_DEV	= $84		;Input device
OUT_DEV	= $85		;Output device
DMABUF	= $86		;original DMA page address
BDOS	= $F0
FCB1	= $F6
FCB2	= $F4
DPH	= $F8		;DPH-VECTOR
DMA	= $FE

STACK	= $100
INBUF	= $200		;BASIC INPUT BUFFER must be at $200!
TPA	= $2000

READTIME = $E2DE	;read time A/X/Y hh/mm/ss

RNDSEED	= $4E		;random number seed

;ERROR CODES

EOF	= $D7
NOTFND	= $DD

;BDOS COMMANDS

CONIN	= $1
CONOUT	= $2
LISTDEV	= $5
CONIO	= $6
STROUT	= $9
CONST	= $B
SELDRV	= $E
DOPEN	= $F
DCLOSE	= $10
ERASE	= $13
RDSEQ	= $14
WRITE	= $15
CREATE	= $16
GETDRV	= $19
BIOSC	= $1A

;BIOS COMMANDS

_CONST	= 2
_CHRIN	= 3
_SETTRK	= 10
_SETSEC = 11
_WRITE	= 13
_RDTIME	= 18

;CONTROL CHARACTERS

EOT	= $00
CTRLA	= $01		;Control A cursor to begin of line
BRK_KEY	= $03
CTRLD	= $04		;Control D
CTRLF	= $06		;Control F
BS	= $08
HT	= $15
LF	= $0A
CLS	= $0C
CR	= $0D
SI	= $0F
CTRLS	= $13		;Control S
;GS	= $1D
SP	= $20
HK	= $22
RUBOUT	= $7F

CURR	= $15		;JC-][ cursor right command

;SPECIAL CODES

BIT_Z	= $24		;BIT Z OPCODE TO MASK 1 BYTE INSTRUCTION
BIT_ABS	= $2C		;BIT OPCODE TO MASK 2 BYTE INSTRUCTION
PRINT_TOK = $99		;PRINT TOKEN

;--------------------------------------------------------

	ORG TPA

	JMP INIT

;---  COMMAND TABLE ---

COM_TAB	DW END-1	;END
	DW FOR-1
	DW NEXT-1
	DW DATA-1
	DW INPUT@-1
	DW INPUT-1
	DW DIM-1
	DW READ-1
	DW LET-1
	DW GOTO-1
	DW RUN-1
	DW IF-1
	DW RESTORE-1
	DW GOSUB-1
	DW RETURN-1
	DW REM-1
	DW STOP-1
	DW ON-1
	DW WAIT-1
	DW LOAD-1
	DW SAVE-1
	DW BYE-1
	DW DEF-1
	DW POKE-1
	DW PRINT@-1
	DW PRINT-1
	DW CONT-1
	DW LIST-1
	DW CLR-1
	DW CMD-1
	DW SYS-1
	DW EDIT-1
	DW KILL-1
	DW GET-1
	DW NEW-1
	DW SGN			;FROM HERE WITHOUT -1
	DW INT
	DW ABS
	DW DUMMY4		;USR NOT IMPLEMENTED
	DW FRE
	DW POS
	DW SQR
	DW RND
	DW LOG
	DW EXP
	DW COS
	DW SIN
	DW TAN
	DW ATN
	DW PEEK
	DW LEN
	DW STR@
	DW VAL
	DW ASC
	DW CHR
	DW LEFT
	DW RIGHT
	DW MID
	DW DUMMY4		;Dummy fn 1
	DW DUMMY4		;Dummy fn 2
	DW DUMMY4		;Dummy fn 3
	DW DUMMY4		;Dummy fn 4
	DW DUMMY4		;Dummy fn 5
	DW DUMMY4		;Dummy fn 6
	DW DUMMY4		;Dummy fn 7
	DW DUMMY4		;Dummy fn 8
	DW DUMMY4		;Dummy fn 9
	DW DUMMY4		;Dummy fn 10
	DW DUMMY4		;Dummy fn 11
	DW DUMMY4		;Dummy fn 12
	DW DUMMY4		;Dummy fn 13
	DW DUMMY4		;Dummy fn 14
	DW DUMMY4		;Dummy fn 15
	DW OPEN-1
	DW CLOSE-1

;--- MATH OPERATORS HIRARCHY AND EXECUTION VECTORS ---
 
OP_TAB	DB $79
	DW PLUS-1
	DB $79
	DW MINUS-1
	DB $7B
	DW MUL-1
	DB $7B
	DW DIV-1
	DB $7F
	DW EXPO-1
	DB $50
	DW AND-1
	DB $46
	DW OR-1
	DB $7D
	DW NEG-1
	DB $5A
	DW NOT-1
	DB $64
	DW COMP-1


;---  BASIC COMMAND WORDS  ---

BAS_BEF	DB 'EN','D'+$80
	DB 'FO','R'+$80
	DB 'NEX','T'+$80
	DB 'DAT','A'+$80
	DB 'INPUT','#'+$80
	DB 'INPU','T'+$80
	DB 'DI','M'+$80
	DB 'REA','D'+$80
	DB 'LE','T'+$80
	DB 'GOT','O'+$80
	DB 'RU','N'+$80
	DB 'I','F'+$80
	DB 'RESTOR','E'+$80
	DB 'GOSU','B'+$80
	DB 'RETUR','N'+$80
	DB 'RE','M'+$80
	DB 'STO','P'+$80
	DB 'O','N'+$80
	DB 'WAI','T'+$80
	DB 'LOA','D'+$80
	DB 'SAV','E'+$80
	DB 'BY','E'+$80
	DB 'DE','F'+$80
	DB 'POK','E'+$80
	DB 'PRINT','#'+$80
	DB 'PRIN','T'+$80
	DB 'CON','T'+$80
	DB 'LIS','T'+$80
	DB 'CL','R'+$80
	DB 'CM','D'+$80
	DB 'SY','S'+$80
	DB 'EDI','T'+$80
	DB 'KIL','L'+$80
	DB 'GE','T'+$80
	DB 'NE','W'+$80
	DB 'TAB','('+$80
	DB 'T','O'+$80
	DB 'F','N'+$80
	DB 'SPC','('+$80
	DB 'THE','N'+$80
	DB 'NO','T'+$80
	DB 'STE','P'+$80
	DB '+'+$80
	DB '-'+$80
	DB '*'+$80
	DB '/'+$80
	DB '^'+$80
	DB 'AN','D'+$80
	DB 'O','R'+$80
	DB '>'+$80
	DB '='+$80
	DB '<'+$80
	DB 'SG','N'+$80
	DB 'IN','T'+$80
	DB 'AB','S'+$80
	DB 'US','R'+$80
	DB 'FR','E'+$80
	DB 'PO','S'+$80
	DB 'SQ','R'+$80
	DB 'RN','D'+$80
	DB 'LO','G'+$80
	DB 'EX','P'+$80
	DB 'CO','S'+$80
	DB 'SI','N'+$80
	DB 'TA','N'+$80
	DB 'AT','N'+$80
	DB 'PEE','K'+$80
	DB 'LE','N'+$80
	DB 'STR','$'+$80
	DB 'VA','L'+$80
	DB 'AS','C'+$80
	DB 'CHR','$'+$80
	DB 'LEFT','$'+$80
	DB 'RIGHT','$'+$80
	DB 'MID','$'+$80
	DB 'US','R'+$80		;Dummy fn 1
	DB 'US','R'+$80		;Dummy fn 2
	DB 'US','R'+$80		;Dummy fn 3
	DB 'US','R'+$80		;Dummy fn 4
	DB 'US','R'+$80		;Dummy fn 5
	DB 'US','R'+$80		;Dummy fn 6
	DB 'US','R'+$80		;Dummy fn 7
	DB 'US','R'+$80		;Dummy fn 8
	DB 'US','R'+$80		;Dummy fn 9
	DB 'US','R'+$80		;Dummy fn 10
	DB 'US','R'+$80		;Dummy fn 11
	DB 'US','R'+$80		;Dummy fn 12
	DB 'US','R'+$80		;Dummy fn 13
	DB 'US','R'+$80		;Dummy fn 14
	DB 'US','R'+$80		;Dummy fn 15
	DB 'OPE','N'+$80
	DB 'CLOS','E'+$80

	DB EOT


;---  ERROR TABLE  ----

ERR_TAB	DB 'NEXT WITHOUT FO','R'+$80
ERR1	DB 'SYNTA','X'+$80
ERR2	DB 'RETURN WITHOUT GOSU','B'+$80
ERR3	DB 'OUT OF DAT','A'+$80
ERR4	DB 'ILLEGAL QUANTIT','Y'+$80
ERR5	DB 'OVERFLO','W'+$80
ERR6	DB 'OUT OF MEMOR','Y'+$80
ERR7	DB 'UNDEF',$27,'D STATEMEN','T'+$80
ERR8	DB 'BAD SUBSCRIP','T'+$80
ERR9	DB 'REDIM',$27,'D ARRA','Y'+$80
ERR10	DB 'DIVISION BY ZER','O'+$80
ERR11	DB 'ILLEGAL DIREC','T'+$80
ERR12	DB 'TYPE MISMATC','H'+$80
ERR13	DB 'STRING TOO LON','G'+$80
ERR14	DB 'FILE DAT','A'+$80
ERR15	DB 'FORMULA TOO COMPLE','X'+$80
ERR16	DB 'CAN',$27,'T CONTINU','E'+$80
ERR17	DB 'UNDEF',$27,'D FUNCTIO','N'+$80
ERR18	DB 'DIS','K'+$80

;---  MESSAGES  ---

ERRORM	DB ' ERROR',EOT
IN_M	DB ' IN ',EOT
READYM	DB CR,LF,'READY.',CR,LF,EOT
BREAKM	DB CR,LF,'BREAK',EOT
REDOM	DB '?REDO FROM START',CR,LF,EOT
EXTRAM	DB '?EXTRA IGNORED',CR,LF,EOT

;---  LEGAL KEYS FOR FILENAMES  ---

KEYTAB	DB '!#$&+^_'
KEYTX

;---  CONSTANTS  ---

PI	DB $82,$49,$0F,$DA,$A1		;3.14159265
M32768	DB $90,$80,$00,$00,$20		;-32768
F_10	DB $84,$20,$00,$00,$00		;10

F_CONST	DB $81,$00,$00,$00,$00		;FLOATING POINT CONSTANTS FOR
F_LOG3	DB $03,$7F,$5E,$56,$CB		;LOG
	DB $79
	DB $80,$13,$9B,$0B,$64
	DB $80,$76,$38,$93,$16
	DB $82,$38,$AA,$3B,$20
F_LOG1	DB $80,$35,$04,$F3,$34
F_LOG2	DB $81,$35,$04,$F3,$34
F_LOG4	DB $80,$80,$00,$00,$00
F_LOG5	DB $80,$31,$72,$17,$F8

F_STR	DB $9B,$3E,$BC,$1F,$FD		;CONSTANT FOR STRING CONVERSION
F_STR1	DB $9E,$6E,$6B,$27,$FD
F_STR2	DB $9E,$6E,$6B,$28,$00

CON_TAB	DB $80,$00,$00,$00,$00		;O.5
CON_C1	DB $FA,$0A,$1F,$00,$00		;CONVERSION CONSTANTS FOR FLOAT
	DB $98,$96,$80,$FF,$F0		;TO ASCII
	DB $BD,$C0,$00,$01,$86
	DB $A0,$FF,$FF,$D8,$F0
	DB $00,$00,$03,$E8,$FF
	DB $FF,$FF,$9C,$00,$00
	DB $00,$0A,$FF,$FF,$FF
	DB $FF,$FF,$DF,$0A,$80
	DB $00,$03,$4B,$C0,$FF
	DB $FF,$73,$60,$00,$00
	DB $0E,$10,$FF,$FF,$FD
	DB $A8,$00,$00,$00,$3C

F_EXP	DB $81,$38,$AA,$3B,$29		;CONSTANTS FOR EXPONENTIATION
F_EXP1	DB $07,$71,$34,$58,$3E
	DB $56
	DB $74,$16,$7E,$B3,$1B
	DB $77,$2F,$EE,$E3,$85
	DB $7A,$1D,$84,$1C,$2A
	DB $7C,$63,$59,$58,$0A
	DB $7E,$75,$FD,$E7,$C6
	DB $80,$31,$72,$18,$10
	DB $81,$00,$00,$00,$00

F_COS	DB $81,$49,$0F,$DA,$A2
F_SIN	DB $83,$49,$0F,$DA,$A2
F_SIN1	DB $7F,$00,$00,$00,$00
F_SIN2	DB $05
	DB $84,$E6,$1A,$2D,$1B
	DB $86,$28,$07,$FB,$F8
	DB $87,$99,$68,$89,$01
	DB $87,$23,$35,$DF,$E1
	DB $86,$A5,$5D,$E7,$28
	DB $83,$49,$0F,$DA,$A2
	DB $A1,$54,$46,$8F,$13
	DB $8F,$52,$43,$89,$CD

F_ATN	DB $0B
	DB $76,$B3,$83,$BD,$D3
	DB $79,$1E,$F4,$A6,$F5
	DB $7B,$83,$FC,$B0,$10
	DB $7C,$0C,$1F,$67,$CA
	DB $7C,$DE,$53,$CB,$C1
	DB $7D,$14,$64,$70,$4C
	DB $7D,$B7,$EA,$51,$7A
	DB $7D,$63,$30,$88,$7E
	DB $7E,$92,$44,$99,$3A
	DB $7E,$4C,$CC,$91,$C7
	DB $7F,$AA,$AA,$AA,$13
	DB $81,$00,$00,$00,$00

C_RND	DB $98,$35,$44,$7A		;CONSTANTS FOR RND
C_RND1	DB $68,$28,$B1,$46

;----------------------

S_FORL	TSX		;SEARCH FOR LOOP IN STACK
	INX
	INX
	INX
	INX
S_FORL3	LDA STACK+1,X
	CMP #$81
	BNE S_FORLX
	LDA P_FORL+1
	BNE S_FORL1
	LDA STACK+2,X
	STA P_FORL
	LDA STACK+3,X
	STA P_FORL+1
S_FORL1	CMP STACK+3,X
	BNE S_FORL2
	LDA P_FORL
	CMP STACK+2,X
	BEQ S_FORLX
S_FORL2	TXA
	CLC
	ADC #$12
	TAX
	BNE S_FORL3
S_FORLX	RTS


M_ROOM	JSR GARBCOL		;MAKE ROOM FOR PROGRAM
	STA VTEND
	STY VTEND+1

MOVE	SEC			;MOVE MEMORY BLOCK IN BEGAD, ENDAD
	LDA ENDAD		;TO TARGAD
	SBC BEGAD
	STA T_PNT
	TAY
	LDA ENDAD+1
	SBC BEGAD+1
	TAX
	INX
	TYA
	BEQ MOVE1
	LDA ENDAD
	SEC
	SBC T_PNT
	STA ENDAD
	BCS MOVE2
	DEC ENDAD+1
	SEC
MOVE2	LDA TARGAD
	SBC T_PNT
	STA TARGAD
	BCS MOVE3
	DEC TARGAD+1
	BCC MOVE3
MOVE4	LDA (ENDAD),Y
	STA (TARGAD),Y
MOVE3	DEY
	BNE MOVE4
	LDA (ENDAD),Y
	STA (TARGAD),Y
MOVE1	DEC ENDAD+1
	DEC TARGAD+1
	DEX
	BNE MOVE3
	RTS


STK_CHK	ASL A			;STACK CHECK
	ADC #$3E
	BCS OM_ERR
	STA T_PNT
	TSX
	CPX T_PNT
	BCC OM_ERR
	RTS


GARBCOL	CPY STREND+1		;GARBAGE COLLECTION
	BCC GACOLX
	BNE GACOL1
	CMP STREND
	BCC GACOLX
GACOL1	PHA
	LDX #9
	TYA
GACOL2	PHA
	LDA BUF1,X
	DEX
	BPL GACOL2
	JSR RM_STR		;REMOVE STRING
	LDX #$F7
GACOL3	PLA
	STA F_ACCU1,X
	INX
	BMI GACOL3
	PLA
	TAY
	PLA
	CPY STREND+1
	BCC GACOLX
	BNE OM_ERR
	CMP STREND
	BCS OM_ERR
GACOLX	RTS


OM_ERR	LDX #ERR6-ERR_TAB	;OUT OF MEMORY ERROR
ERROR	LSR OUT_F		;ERROR MESSAGES
	LDA IO_CHAN		;CHECK OUTPUT FLAG
	BEQ ERROR1
	JSR RES_IO		;IN_DEV=0, OUT_DEV=3
ERROR1	JSR CRLF		;PRINT CR, LF
	JSR PRT_3F		;PRINT ?
ERROR2	LDA ERR_TAB,X
	PHA
	AND #$7F
	JSR PRT_CHR		;PRINT CHR
	INX
	PLA
	BPL ERROR2
	JSR RESET
	LDA #ERRORM		;PRINT ' ERROR'
	LDY #ERRORM/256
ERROR3	JSR PRT_STR
	LDY DIRECT_F
	INY
	BEQ WARM
	JSR PRT_LNR		;PRINT LINE NR


WARM	LSR OUT_F		;BASIC WARM START
	LDA #READYM
	LDY #READYM/256
	JSR PRT_STR

MAIN	JSR GETLINE		;BASIC MAIN LOOP
MAIN7	STX CHRGTP		;STORE TO CHR GET POINTER
	STY CHRGTP+1
	JSR GETCHR		;GET NEXT CHR
	TAX
	BEQ MAIN
	LDX #$FF
	STX DIRECT_F
	BCC MAIN1
	JSR G_TOKEN		;GET BASIC TOKEN
	JMP EXEC
MAIN1	JSR G_FIX		;GET FIXED DIGIT NR
	JSR G_TOKEN
	STY INBUFP		;INPUT BUFFER POINTER
	JSR G_LINNR		;GET LINE NR
	BCC MAIN2
	LDY #1
	LDA (BEGAD),Y
	STA T_PNT+1
	LDA VTBEG
	STA T_PNT
	LDA BEGAD+1
	STA PNT+1
	LDA BEGAD
	DEY
	SBC (BEGAD),Y
	CLC
	ADC VTBEG
	STA VTBEG
	STA PNT
	LDA VTBEG+1
	ADC #$FF
	STA VTBEG+1
	SBC BEGAD+1
	TAX
	SEC
	LDA BEGAD
	SBC VTBEG
	TAY
	BCS MAIN3
	INX
	DEC PNT+1
MAIN3	CLC
	ADC T_PNT
	BCC MAIN4
	DEC T_PNT+1
	CLC
MAIN4	LDA (T_PNT),Y
	STA (PNT),Y
	INY
	BNE MAIN4
	INC T_PNT+1
	INC PNT+1
	DEX
	BNE MAIN4
MAIN2	JSR BAS_RST		;BASIC RESET
	JSR L_INS
	LDA INBUF
	BEQ MAIN
	CLC
	LDA VTBEG
	STA ENDAD
	ADC INBUFP
	STA TARGAD
	LDY VTBEG+1
	STY ENDAD+1
	BCC MAIN5
	INY
MAIN5	STY TARGAD+1
	JSR M_ROOM
	LDA BASADR
	LDY BASADR+1
	STA STACK+$FE
	STY STACK+$FF
	LDA VTEND
	LDY VTEND+1
	STA VTBEG
	STY VTBEG+1
	LDY INBUFP
	DEY
MAIN6	LDA STACK+$FC,Y
	STA (BEGAD),Y
	DEY
	BPL MAIN6
MAIN0	JSR BAS_RST
	JSR L_INS
	JMP MAIN

L_INS	LDA BASBEG		;LINE INSERT/DELETE
	LDY BASBEG+1
	STA T_PNT
	STY T_PNT+1
	CLC
L_INS2	LDY #1
	LDA (T_PNT),Y
	BEQ L_INSX
	LDY #4
L_INS1	INY
	LDA (T_PNT),Y
	BNE L_INS1
	INY
	TYA
	ADC T_PNT
	TAX
	LDY #0
	STA (T_PNT),Y
	LDA T_PNT+1
	ADC #0
	INY
	STA (T_PNT),Y
	STX T_PNT
	STA T_PNT+1
	BCC L_INS2
L_INSX	RTS


GETLINE	LDX #0			;GET LINE FROM input device
	LDY IN_DEV
	BEQ GETLIN1
GETLN1	STX TEMPX
	LDX #CONIN		;get chr from CON
	JSR BDOS
	LDX TEMPX
	CMP #LF			;ignore LF's
	BEQ GETLN1
	CMP #CR
	BEQ GETLNX
	STA INBUF,X
	INX
	BNE GETLN1
GETLNX	JMP ST_EOT

GETLIN7	DEX			;do RUBOUT
	BMI GETLIN3
	DEX
	STX P_FORL
	LDA #BS
GL_RUB	INX
	JSR CHROUT
	LDA INBUF+1,X
	STA INBUF,X
	BNE GL_RUB
	LDA #SP			;delete last CHR
	JSR CHROUT
	JMP GLBCUR2

GETLIN1	LDA IO_CHAN		;switch io channel to console
	PHA
	STX IO_CHAN
	STX INBUF
	DB BIT_Z
GETLIN3	INX
GETLIN0	STX TEMPX
	LDA #$FF
	JSR CHROUT5		;INPUT CHR VIA BDOS06/BIOS
	CMP #CR			;CR
	BNE GETLIN2
	JSR ST_EOT
	PLA
	STA IO_CHAN		;restore io channel
	RTS

GETLIN2	CMP #RUBOUT		;Delete CHR left from cursor
	BEQ GETLIN7
	CMP #SP
	BCC GETLIN4
GL_INS	STX P_FORL		;CHR insert into line
GL_INS1	LDY INBUF,X
	STA INBUF,X
	JSR CHROUT		;ECHO CHR TO SCREEN
	INX
	TYA
	BNE GL_INS1
	STA INBUF,X
GL_BCUR	DEX			;Move cursor back
GLBCUR1	CPX P_FORL
	BEQ GETLIN3
GLBCUR2	LDA #BS			;do a backspace
	JSR CHROUT
	JMP GL_BCUR

GETLIN4	CMP #BS
	BNE GETLIN5
GETLN4B	LDA #BS
	DEX
	BMI GETLIN3
GETLN4A	JSR CHROUT
	JMP GETLIN0

GETLIN5	CMP #HT
	BNE GETLIN6
GETLN5A	LDA INBUF,X
	BEQ GETLIN0
	INX
	BNE GETLN4A		;emit chr under cursor

GETLIN6	CMP #SI			;toggle echo
	BNE G_CHR1
	LDA OUT_F
	EOR #$FF
	STA OUT_F
GETLN10	JMP GETLIN0

G_CHR1	CMP #CTRLA		;cursor to begin of line
	BNE GETLIN8
	LDA #$FF
	STA P_FORL
	BNE GL_BCUR

GETLIN8	CMP #CTRLF		;move cursor to EOL
	BNE GETLIN9
	DB BIT_Z
GETLN8A	PHA			;entry from EDIT
GETLN8B	LDA INBUF,X
	BEQ GETLIN0
	JSR CHROUT
	INX
	BNE GETLN8B

GETLIN9	CMP #CTRLS
	BEQ GETLN4B
	CMP #CTRLD
	BEQ GETLN5A	
	BNE GETLN10		;all other chr's suppressed


UCASE	CMP #'a			;upper case conversion
	BCC UCASEX
	CMP #'{
	BCS UCASEX
	AND #$5F
UCASEX	RTS


G_TOKEN	LDX CHRGTP		;GET BASIC TOKEN
	LDY #4
	STY DATA_F
G_TOK1	LDA INBUF,X
	BPL G_TOK2
	INX
	BNE G_TOK1
G_TOK2	CMP #SP
	BEQ G_TOK3
	STA HK_F
	CMP #HK
	BEQ G_TOK4
	BIT DATA_F
	BVS G_TOK3
	CMP #'?
	BNE G_TOK5
	LDA #PRINT_TOK
	BNE G_TOK3
G_TOK5	CMP #'0
	BCC G_TOK6
	CMP #'<
	BCC G_TOK3
G_TOK6	STY P_FUNC
	JSR S_BBEF
	STX CHRGTP
	LDY #0
	STY INBUFP
G_TOK14	LDA INBUF,X
	JSR UCASE		;lower -> upper case
	SEC
	SBC (PNT),Y
	BNE G_TOK7
	INX
	INY
	BNE G_TOK14
G_TOK17	INC PNT+1
	BNE G_TOK14

G_TOK7	CMP #$80		;BASIC COMMAND?
	BNE G_TOK8
	ORA INBUFP
G_TOK15	LDY P_FUNC
G_TOK3	INX
	INY
	JSR UCASE
	STA INBUF-5,Y
	ORA #$00		;END OF LINE?
	BEQ G_TOK9
	SEC
	SBC #':
	BEQ G_TOK10
	CMP #73			;DATA Token?
	BNE G_TOK11
G_TOK10	STA DATA_F
G_TOK11	SEC
	SBC #85
	BNE G_TOK1
	STA HK_F
G_TOK12	LDA INBUF,X
	BEQ G_TOK3
	CMP HK_F
	BEQ G_TOK3
G_TOK4	INY
	STA INBUF-5,Y
	INX
	BNE G_TOK12
G_TOK8	LDX CHRGTP
	INC INBUFP
G_TOK13	LDA (PNT),Y
	BMI G_TOK16
	INY
	BNE G_TOK13
	INC PNT+1
	BNE G_TOK13

G_TOK16	INY
	BEQ G_TOK17
	LDA (PNT),Y
	BNE G_TOK14
	LDA INBUF,X
	BPL G_TOK15
G_TOK9	STA INBUF-3,Y
	DEC CHRGTP+1
	LDA #INBUF-1
	STA CHRGTP
	RTS


S_BBEF	LDY #BAS_BEF		;set PNT = BAS_BEF
	STY PNT
	LDY #BAS_BEF/256
	STY PNT+1
	RTS


G_LINNR	LDA BASBEG		;GET BASIC LINE NR
	LDX BASBEG+1
G_LINN4	LDY #1
	STA BEGAD
	STX BEGAD+1
	LDA (BEGAD),Y
	BEQ G_LINN1
	INY
	INY
	LDA BASADR+1
	CMP (BEGAD),Y
	BCC G_LINNX
	BEQ G_LINN2
	DEY
	BNE G_LINN3
G_LINN2	LDA BASADR
	DEY
	CMP (BEGAD),Y
	BCC G_LINNX
	BEQ G_LINNX
G_LINN3	DEY
	LDA (BEGAD),Y
	TAX
	DEY
	LDA (BEGAD),Y
	BCS G_LINN4
G_LINN1	CLC
G_LINNX	RTS


NEW	BNE G_LINNX		;NEW COMMAND
COLD	LDA #0
	TAY
	STA (BASBEG),Y
	INY
	STA (BASBEG),Y
	LDA BASBEG
	CLC
	ADC #2
	STA VTBEG
	LDA BASBEG+1
	ADC #0
	STA VTBEG+1
BAS_RST JSR SET_CGP		;SET CHR GET POINTER
	LDA #0

CLR	BNE CLRX		;CLR COMMAND
CLR1	LDA NXTAD
	LDY NXTAD+1
	STA STREND
	STY STREND+1
	JSR RES_IO
	LDA VTBEG
	LDY VTBEG+1
	STA ATBEG
	STY ATBEG+1
	STA VTEND
	STY VTEND+1
	JSR RESTORE
RESET	LDX #STRTAB
	STX DES_PNT
	PLA
	TAY
	PLA
	LDX #$FA
	TXS
	PHA
	TYA
	PHA
	LDA #0
	STA NXTBEF+1
	STA DIM_F
CLRX	RTS


SET_CGP	CLC			;SET CHR POINTER ON START
	LDA BASBEG
	ADC #$FF
	STA CHRGTP
	LDA BASBEG+1
	ADC #$FF
	STA CHRGTP+1
SET_CGX	RTS


LIST	BCC LIST1		;LIST COMMAND
	BEQ LIST1
	CMP #$AB		;- TOKEN
	BNE SET_CGX
LIST1	JSR G_FIX
	JSR G_LINNR
	JSR GETCHR1
	BEQ LIST2
	CMP #$AB		;- TOKEN
	BNE SET_CGX
	JSR GETCHR
	JSR G_FIX
	BNE SET_CGX
LIST2	PLA
	PLA
	LDA BASADR
	ORA BASADR+1
	BNE LIST3
	LDA #$FF
	STA BASADR
	STA BASADR+1
LIST3	LDY #1
	STY DATA_F
	LDA (BEGAD),Y
	BEQ LIST4
	JSR BRKTST
	JSR CRLF
	INY
	LDA (BEGAD),Y
	TAX
	INY
	LDA (BEGAD),Y
	CMP BASADR+1
	BNE LIST5
	CPX BASADR
	BEQ LIST6
LIST5	BCS LIST4
LIST6	STY P_FORL
	JSR PRT_16
	LDA #SP
LIST13	LDY P_FORL
	AND #$7F
LIST9	JSR PRT_CHR
	CMP #'"
	BNE LIST7
	LDA DATA_F
	EOR #$FF
	STA DATA_F
LIST7	INY
	BEQ LIST4
	LDA (BEGAD),Y
	BNE LIST8
	TAY
	LDA (BEGAD),Y
	TAX
	INY
	LDA (BEGAD),Y
	STX BEGAD
	STA BEGAD+1
	BNE LIST3
LIST4	JMP WARM

LIST8	BPL LIST9
	BIT DATA_F
	BMI LIST9
	JSR F_BBEF		;find basic command
LIST10	LDA (PNT),Y
	BMI LIST13
	JSR PRT_CHR
	INY
	BNE LIST10
	INC PNT+1
	BNE LIST10


EDIT	BEQ LIST4		;EDIT COMMAND
	JSR G_FIX		;get line nr from command line
EDIT1	JSR G_LINNR		;search line
	LDY #2
	LDA (BEGAD),Y		;GET LINE NR
	STA F_ACCU1+2
	INY
	LDA (BEGAD),Y
	STA F_ACCU1+1
	STY P_FORL		;SAVE Y
	LDX #$90
	SEC
	JSR INTFLT		;CONVERT INT TO FLT
	JSR FLT_ASC		;CONVERT FLT TO ASCII
	LDX #0			;X is INBUF pointer
EDIT2	LDA STACK,X		;COPY ASCII NR TO INPUT BUFFER
	BEQ EDIT7
	STA INBUF,X
	INX
	BPL EDIT2

EDIT7	LDA #SP			;SPACE
EDIT3	LDY P_FORL
	AND #$7F
EDIT5	STA INBUF,X
	INX
	INY
	BEQ LIST4
	LDA (BEGAD),Y		;GET NEXT CHR
	BEQ EDIT4		;IF NOT EOL
	BPL EDIT5		;AND NOT A TOKEN
	STX P_FORL+1
	JSR F_BBEF		;FIND BASIC COMMAND
	LDX P_FORL+1
EDIT6	LDA (PNT),Y
	BMI EDIT3
	STA INBUF,X
	INX
	INY
	BNE EDIT6
	INC PNT+1
	BNE EDIT6

EDIT4	STA INBUF,X		;STORE 0 TO END OF STRING
	JSR RES_IO
	TAX			;X=0!
	JSR GETLN8A
	JMP MAIN7


F_BBEF	STY P_FORL		;find basic command
	JSR S_BBEF
	LDY #0
	AND #$7F
	TAX
	BEQ FBBEFX
FBBEF2	LDA (PNT),Y
	BPL FBBEF1
	DEX
	BEQ FBBEF3
FBBEF1	INY
	BNE FBBEF2
	INC PNT+1
	BNE FBBEF2

FBBEF3	INY
	BNE FBBEFX
	INC PNT+1
FBBEFX	RTS


FOR	LDA #$80		;FOR COMMAND
	STA DIM_F
	JSR LET
	JSR S_FORL
	BNE FOR1
	TXA
	ADC #$0F
	TAX
	TXS
FOR1	PLA
	PLA
	LDA #9
	JSR STK_CHK
	JSR S_NXTC
	CLC
	TYA
	ADC CHRGTP
	PHA
	LDA CHRGTP+1
	ADC #0
	PHA
	LDA ALINNR+1
	PHA
	LDA ALINNR
	PHA
	LDA #$A4		;CHECK FOR 'TO' TOKEN?
	JSR CHK_CHR
	JSR CHK_NUM
	JSR ANALYZE
	LDA F_ACCU1+5
	ORA #$7F
	AND F_ACCU1+1
	STA F_ACCU1+1
	LDA #FOR2
	LDY #FOR2/256
	STA T_PNT
	STY T_PNT+1
	JMP DOIT2

FOR2	LDA #F_CONST
	LDY #F_CONST/256
	JSR FIL_A1
	JSR GETCHR1
	CMP #$A9			;CHECK FOR 'STEP' TOKEN
	BNE FOR3
	JSR GETCHR
	JSR ANALYZE
FOR3	JSR CHK_A1S
	JSR DOIT1
	LDA P_FORL+1
	PHA
	LDA P_FORL
	PHA
	LDA #$81
	PHA

EX_NXTC	JSR BRKTST		;EXECUTE NEXT BASIC COMMAND
	LDA CHRGTP
	LDY CHRGTP+1
	CPY #INBUF/256		;Direct mode?
	BEQ EXNXTC1
	STA NXTBEF
	STY NXTBEF+1
EXNXTC1	LDY #0
	LDA (CHRGTP),Y
	BNE EXEC8
	LDY #2
	LDA (CHRGTP),Y
	CLC
	BNE EXNXTC2
	JMP BREAK4

EXNXTC2	INY
	LDA (CHRGTP),Y
	STA ALINNR
	INY
	LDA (CHRGTP),Y
	STA ALINNR+1
	TYA
	ADC CHRGTP
	STA CHRGTP
	BCC EXEC
	INC CHRGTP+1
EXEC	JSR GETCHR		;EXECUTE BASIC COMMAND
	JSR EXE
	JMP EX_NXTC


EXE	BEQ RESTORX		;EXEC BASIC COMMAND AS SUBROUTINE
EXEC1	SBC #$80
	BCC EXEC2
	CMP #35			;max. 35 BASIC COMMANDS as RTS-JUMP
	BCS EXEC3
EXEC5	ASL A
	TAY
	LDA COM_TAB+1,Y
	PHA
	LDA COM_TAB,Y
	PHA
	JMP GETCHR

EXEC2	JMP LET

EXEC8	CMP #':
	BEQ EXEC
EXEC4	JMP SYN_ERR

EXEC3	CMP #90			;new functions
	BCC EXEC4
	CMP #92
	BCS EXEC4
	SBC #16			;adjust pointer
	BCS EXEC5


RESTORE	SEC			;RESTORE COMMAND
	LDA BASBEG
	SBC #1
	LDY BASBEG+1
	BCS RESTOR1
	DEY
RESTOR1	STA NXTDATA
	STY NXTDATA+1
RESTORX	RTS


STOP	BCS STOP1		;STOP COMMAND
END	CLC			;EXECUTE ALSO END AND BREAK
STOP1	BNE CONTX
	LDA CHRGTP
	LDY CHRGTP+1
	LDX ALINNR+1
	INX
	BEQ STOP2
	STA NXTBEF
	STY NXTBEF+1
STOP4	LDA ALINNR
	LDY ALINNR+1
	STA CONTLN
	STY CONTLN+1
STOP2	PLA
	PLA
BREAK4	LDA #BREAKM
	LDY #BREAKM/256
	LDX #0
	STX OUT_F		;OUTPUT ENABLE
	BCC STOP3
	JMP ERROR3		;BREAK IN ...

STOP3	JMP WARM		;'READY'


CONT	BNE CONTX		;CONT COMMAND
	LDX #ERR16-ERR_TAB
	LDY NXTBEF+1
	BNE CONT1
	JMP ERROR
CONT1	LDA NXTBEF
	STA CHRGTP
	STY CHRGTP+1
	LDA CONTLN
	LDY CONTLN+1
	STA ALINNR
	STY ALINNR+1
CONTX	RTS


RUN	BNE GOSUB0		;RUN COMMAND
	JMP BAS_RST


GOSUB0	JSR CLR1
	JMP GOSUB1

GOSUB	LDA #3			;GOSUB COMMAND
	JSR STK_CHK
	LDA CHRGTP+1
	PHA
	LDA CHRGTP
	PHA
	LDA ALINNR+1
	PHA
	LDA ALINNR
	PHA
	LDA #$8D		;GOSUB TOKEN
	PHA
GOSUB1	JSR GETCHR1
	JSR GOTO
	JMP EX_NXTC


GOTO	JSR G_FIX		;GOTO COMMAND
	JSR S_NXTL
	LDA ALINNR+1
	CMP BASADR+1
	BCS GOTO1
	TYA
	SEC
	ADC CHRGTP
	LDX CHRGTP+1
	BCC GOTO2
	INX
	BCS GOTO2
GOTO1	LDA BASBEG
	LDX BASBEG+1
GOTO2	JSR G_LINN4
	BCC UDF_ERR
	LDA BEGAD
	SBC #1
	STA CHRGTP
	LDA BEGAD+1
	SBC #0
	STA CHRGTP+1
GOTO3	RTS


RETURN	BNE GOTO3		;RETURN COMMAND
	LDA #$FF
	STA P_FORL+1
	JSR S_FORL
	TXS
	CMP #$8D		;GOSUB TOKEN
	BEQ DATA0
	LDX #ERR2-ERR_TAB	;RETURN WITHOUT GOSUB
	DB BIT_ABS
UDF_ERR	LDX #ERR7-ERR_TAB	;UNDEF'D STAEMENT
	JMP ERROR

RETURN1	JMP SYN_ERR		;SYNTAX ERROR


DATA0	PLA
	PLA
	STA ALINNR
	PLA
	STA ALINNR+1
	PLA
	STA CHRGTP
	PLA
	STA CHRGTP+1
DATA	JSR S_NXTC		;DATA COMMAND
DATA1	TYA
	CLC
	ADC CHRGTP
	STA CHRGTP
	BCC DATAX
	INC CHRGTP+1
DATAX	RTS


S_NXTC	LDX #':			;SEARCH NEXT COMMAND
	DB BIT_ABS
S_NXTL	LDX #0			;SEARCH NEXT LINE
	STX SRC_CHR
	LDY #0
	STY HK_F
S_NXT1	LDA HK_F
	LDX SRC_CHR
	STA SRC_CHR
	STX HK_F
S_NXT2	LDA (CHRGTP),Y
	BEQ DATAX
	CMP HK_F
	BEQ DATAX
S_NXT3	INY
	CMP #'"
	BNE S_NXT2
	BEQ S_NXT1


IF	JSR IN_TERM		;IF COMMAND
	JSR GETCHR1
	CMP #$89		;GOTO TOKEN
	BEQ IF1
	LDA #$A7		;THEN TOKEN
	JSR CHK_CHR
IF1	LDA F_ACCU1
	BNE REM1


REM	JSR S_NXTL		;REM COMMAND
	BEQ DATA1
REM1	JSR GETCHR1
	BCS REM2
	JMP GOTO
REM2	JMP EXE


ON	JSR TRMCALC		;ON COMMAND
	PHA
	CMP #$8D		;GOSUB TOKEN
	BEQ ON1
ON4	CMP #$89		;GOTO TOKEN
	BNE RETURN1		;SYNTAX ERROR
ON1	DEC F_ACCU1+4
	BNE ON2
	PLA
	JMP EXEC1

ON2	JSR GETCHR
	JSR G_FIX
	CMP #',
	BEQ ON1
	PLA
ON3	RTS


G_FIX	LDX #0			;GET FIXED DIGIT NR
	STX BASADR
	STX BASADR+1
G_FIX1	BCS ON3
	SBC #'0'-1		;C=0 !
	STA SRC_CHR		;ASCII TO HEX CONVERSION
	LDA BASADR+1
	STA T_PNT
	CMP #$19
	BCS ON4
	LDA BASADR
	ASL A
	ROL T_PNT
	ASL A
	ROL T_PNT
	ADC BASADR
	STA BASADR
	LDA T_PNT
	ADC BASADR+1
	STA BASADR+1
	ASL BASADR
	ROL BASADR+1
	LDA BASADR
	ADC SRC_CHR
	STA BASADR
	BCC G_FIX2
	INC BASADR+1
G_FIX2	JSR GETCHR
	JMP G_FIX1


LET	JSR S_VAR		;LET COMMAND
	STA P_FORL
	STY P_FORL+1
	LDA #$B2		;TOKEN FOR '=
	JSR CHK_CHR
	LDA INT_F
	PHA
	LDA VAR_F
	PHA
	JSR IN_TERM
	PLA
	ROL A
	JSR CHK_NUX
	BNE LET2
	PLA
LET1	BPL LET3
	JSR A1RND		;ROUND ACCU 1
	JSR F_INT1		;CONVERT TO INT
	LDY #0
	LDA F_ACCU1+3
	STA (P_FORL),Y
	INY
	LDA F_ACCU1+4
	STA (P_FORL),Y
	RTS

LET3	JMP A1_FOR

LET2	PLA
LET4	LDY P_FORL+1
	CPY #CON_TAB+2/256	;if TI$ !!!
	BNE LETA
	JSR GARCOL1
	CMP #$6
	BNE ASC_IN1
	LDY #0
	STY F_ACCU1
	STY F_ACCU1+5
LET6	STY P_FUNC
	JSR ASC_IN
	JSR A1MUL10		;ACCU1 * 10
	INC P_FUNC
	LDY P_FUNC
	JSR ASC_IN
	JSR A1_A2		;COPY ACCU1 TO ACCU2
	TAX
	BEQ LET5
	INX
	TXA
	JSR A1MUL1A
LET5	LDY P_FUNC
	INY
	CPY #6
	BNE LET6
	JSR A1MUL10
	JSR FN_INT
	LDX #2
LET7	LDA F_ACCU1+2,X
	STA CLOCK,X
	DEX
	BPL LET7
	RTS


ASC_IN	LDA (T_PNT),Y		;READ ASCII NR IN ACCU 1
	JSR GETCHR2
	BCC ASC_IN2
ASC_IN1	JMP ILLQ_ERR		;ILLEGAL QUANTITY ERROR
ASC_IN2	SBC #$2F
	JMP RD_ASCNR

LETA	LDY #2
	LDA (F_ACCU1+3),Y
	CMP STREND+1
	BCC LETA1
	BNE LETA2
	DEY
	LDA (F_ACCU1+3),Y
	CMP STREND
	BCC LETA1
LETA2	LDY F_ACCU1+4
	CPY VTBEG+1
	BCC LETA1
	BNE LETA3
	LDA F_ACCU1+3
	CMP VTBEG
	BCS LETA3
LETA1	LDA F_ACCU1+3
	LDY F_ACCU1+4
	JMP LETA4
LETA3	LDY #0
	LDA (F_ACCU1+3),Y
	JSR G_STRP		;GET STRING POINTER
	LDA GCMEM
	LDY GCMEM+1
	STA ACOMP
	STY ACOMP+1
	JSR STR_MEM
	LDA #$5E
	LDY #0
LETA4	STA GCMEM
	STY GCMEM+1
	JSR FIX_DT		;FIX DESCRIPTOR TABLE
	LDY #0
	LDA (GCMEM),Y
	STA (P_FORL),Y
	INY
	LDA (GCMEM),Y
	STA (P_FORL),Y
	INY
	LDA (GCMEM),Y
	STA (P_FORL),Y
	RTS


PRINT@	JSR CMD			;PRINT# COMMAND
	JMP RES_IO


CMD	JSR TRMCALC		;CMD COMMAND
	BEQ CMD1
	JSR CHK_KM
CMD1	PHP
	JSR SET_OUT
	STX IO_CHAN		;set IO channel
	PLP
	JMP PRINT


PRINT1	JSR PRT_STR1		;PRINT COMMAND
PRINT0	JSR GETCHR1
PRINT	BEQ CRLF
PRINT2	BEQ PRINTX
	CMP #$A3		;TAB()
	BEQ TAB
	CMP #$A6		;SPC()
	CLC
	BEQ TAB
	CMP #',
	BEQ PRINT4
	CMP #';
	BEQ TAB3		;REPEAT PRINT
	JSR IN_TERM
	BIT VAR_F
	BMI PRINT1		;IF VARTYP = STRING
	JSR FLT_ASC		;CONVERT FLOAT TO ASCII
	JSR S_STR		;SEARCH STRING ELEMENT
	JSR PRT_STR1		;PRINT AND REMOVE IT
	JSR PRT			;PRINT CHARACTER '> OR ' '
	BNE PRINT0
ST_EOT	LDA #0			;SAVE $00 AS EOT
	STA INBUF,X
	LDX #INBUF-1
	LDY #INBUF-1/256
	LDA IO_CHAN
	BNE PRINTX		;IF IO-CHANNEL <> 0 THEN RTS
CRLF	LDA #CR
	JSR PRT_CHR
	LDA #LF
	JSR PRT_CHR
	EOR #$FF
PRINTX	RTS

PRINT4	LDA CUR_COL
	SEC
PRINT8	SBC #10
	BCS PRINT8
	EOR #$FF
	ADC #1
	BNE TAB1
TAB	PHP
	JSR TRMCAL0
	CMP #')
	BNE PRT_ERR
	PLP
	BCC TAB2
	TXA
	SBC CUR_COL
	BCC TAB3
TAB1	TAX
TAB2	INX
TAB4	DEX
	BNE TAB5
TAB3	JSR GETCHR
	JMP PRINT2

TAB5	JSR PRT
	BNE TAB4

PRT_STR	JSR S_STR		;PRINT STRING IN A/Y
PRT_STR1 JSR GARCOL1
	TAX
	LDY #0
	INX
PRT_ST2	DEX
	BEQ PRINTX		;EOT!
	LDA (T_PNT),Y
	JSR PRT_CHR
	INY
	BNE PRT_ST2


PRT	LDA IO_CHAN		;PRINT 1 CHR
	BEQ PRT_SP
	LDA #SP
	DB BIT_ABS
PRT_SP	LDA #SP			;for VT-100 compatibility, was $09
	DB BIT_ABS
PRT_3F	LDA #'?
PRT_CHR	BIT OUT_F
	BMI PRT1
	PHA
	JSR CHROUT
	PLA
PRT1	AND #$FF		;RESET N AND Z FLAGS
	RTS


INP_ERR	LDA INP_F		;HANDLE INPUT ERRORS
	BEQ INP_ER1
	BMI INP_ER2
	LDY #$FF
	BNE INP_ER3
INP_ER2	LDA ADATA
	LDA ADATA+1
INP_ER3	STA ALINNR
	STY ALINNR+1
PRT_ERR	JMP SYN_ERR		;SYNTAX ERROR
INP_ER1	LDA IO_CHAN
	BEQ INP_ER4
	LDX #ERR14-ERR_TAB	;FILE DATA ERROR
 	JMP ERROR

INP_ER4	LDA #REDOM
	LDY #REDOM/256
	JSR PRT_STR
	LDA NXTBEF
	LDY NXTBEF+1
	STA CHRGTP
	STY CHRGTP+1
	RTS


GET	JSR DIR_TST		;GET COMMAND
	CMP #'#			;TEST FOR DIRECT MODE
	BNE GET1
	JSR GETCHR
	JSR GETARG
GET1	LDX #INBUF+1
	LDY #INBUF+1/256
	LDA #0
	STA INBUF+1
	LDA #$40		;INPUT FLAG
	JSR READ1
	LDX IO_CHAN
	BNE INP@1
	RTS


GETARG	JSR TRMCALC		;GET ARGUMENT
	JSR CHK_KM		;CHECK FOR KOMMA
	JSR SET_IN		;SET INPUT DEVICE
	STX IO_CHAN
	RTS


INPUT@	JSR GETARG		;INPUT# COMMAND
	JSR INPUT1
INP@1	JMP RES_IO


INPUT	LSR OUT_F		;INPUT COMMAND
	CMP #'"
	BNE INPUT1
	JSR CHK_ST1
	LDA #';
	JSR CHK_CHR
	JSR PRT_STR1
INPUT1	JSR DIR_TST		;TEST FOR DIRECT MODE
	LDA #',
	STA STACK+$FF
INPUT3	JSR INP_EX
	LDA IO_CHAN
	BEQ INPUT2
	LDA STATUS
	AND #$40		;EOF reached?
	BEQ INPUT2
	JSR RES_IO
	JMP DATA

INPUT2	LDA INBUF
	BNE READ2
	LDA IO_CHAN
	BNE INPUT3
	CLC
	JMP STOP4

INP_EX	LDA IO_CHAN
	BNE INP_EX1
	JSR PRT_3F
	JSR PRT
INP_EX1	JMP GETLINE


READ	LDX NXTDATA		;READ COMMAND
	LDY NXTDATA+1
	LDA #$98
	DB BIT_ABS
READ2	LDA #00
READ1	STA INP_F
	STX INPPNT
	STY INPPNT+1
READ3	JSR S_VAR
	STA P_FORL
	STY P_FORL+1
	LDA CHRGTP
	LDY CHRGTP+1
	STA AOPER
	STY AOPER+1
	LDX INPPNT
	LDY INPPNT+1
	STX CHRGTP
	STY CHRGTP+1
	JSR GETCHR1
	BNE READ4
	BIT INP_F
	BVC READ5
	JSR CHRIN
	STA INBUF
	LDX #INBUF-1
	LDY #INBUF-1/256
	BNE READ6

READ5	BMI READ10
	LDA IO_CHAN
	BNE READ7
	JSR PRT_3F
READ7	JSR INP_EX
READ6	STX CHRGTP
	STY CHRGTP+1
READ4	JSR GETCHR
	BIT VAR_F
	BPL READ20
	BIT INP_F
	BVC READ8
	INX
	STX CHRGTP
	LDA #0
	STA SRC_CHR
	BEQ READ9
READ8	STA SRC_CHR
	CMP #'"
	BEQ READ11
	LDA #':
	STA SRC_CHR
	LDA #',
READ9	CLC
READ11	STA HK_F
	LDA CHRGTP
	LDY CHRGTP+1
	ADC #0
	BCC READ12
	INY
READ12	JSR S_STR1
	JSR VAL8
	JSR LET4
	JMP READ21

READ20	JSR STR_VAL
	LDA INT_F
	JSR LET1
READ21	JSR GETCHR1
	BEQ READ22
	CMP #',
	BEQ READ22
	JMP INP_ERR
READ22	LDA CHRGTP
	LDY CHRGTP+1
	STA INPPNT
	STY INPPNT+1
	LDA AOPER
	LDY AOPER+1
	STA CHRGTP
	STY CHRGTP+1
	JSR GETCHR1
	BEQ READ23
	JSR CHK_KM
	JMP READ3

READ10	JSR S_NXTC
	INY
	TAX
	BNE READ24
	LDX #'*
	INY
	LDA (CHRGTP),Y
	BEQ NEXT2
	INY
	LDA (CHRGTP),Y
	STA ADATA
	INY
	LDA (CHRGTP),Y
	INY
	STA ADATA+1
READ24	LDA (CHRGTP),Y
	TAX
	JSR DATA1
	CPX #$83
	BNE READ10
	JMP READ4

READ23	LDA INPPNT
	LDY INPPNT+1
	LDX INP_F
	BPL READ25
	JMP RESTOR1

READ25	LDY #0
	LDA (INPPNT),Y
	BEQ READX
	LDA IO_CHAN
	BNE READX
	LDA #EXTRAM
	LDY #EXTRAM/256
	JMP PRT_STR

READX	RTS


NEXT	BNE NEXT1		;NEXT COMMAND
	LDY #0
	BEQ NEXT3
NEXT1	JSR S_VAR
NEXT3	STA P_FORL
	STY P_FORL+1
	JSR S_FORL
	BEQ NEXT4
	LDX #ERR_TAB-ERR_TAB
NEXT2	BEQ TM_ERR1		;NEXT WITHOUT FOR ERROR
NEXT4	TXS
	TXA
	CLC
	ADC #4
	PHA
	ADC #6
	STA PNT
	PLA
	LDY #1
	JSR FIL_A1
	TSX
	LDA STACK+9,X
	STA F_ACCU1+5
	LDA P_FORL
	LDY P_FORL+1
	JSR V_PA1
	JSR A1_FOR
	LDY #1
	JSR COMPA11
	TSX
	SEC
	SBC STACK+9,X
	BEQ CHK_DF
	LDA STACK+$F,X
	STA ALINNR
	LDA STACK+$10,X
	STA ALINNR+1
	LDA STACK+$12,X
	STA CHRGTP
	LDA STACK+$11,X
	STA CHRGTP+1
NEXT5	JMP EX_NXTC


CHK_DF	TXA			;CHECK DATA FORMAT
	ADC #$11
	TAX
	TXS
	JSR GETCHR1
	CMP #',
	BNE NEXT5
	JSR GETCHR
	JSR NEXT1

	APP BASIC0.APP
